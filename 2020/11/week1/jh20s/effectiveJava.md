2장 객체 생성과 파괴

1. 생성자 대신 정적 패터리 메서드를 고려하라
클래스는 클라어언트에 public 생성자 대신 정적 메서드를 제공할 수 있다.
장점 1) 이름을 가질 수 있다. 그로인해 반환될 객체의 특성등을 쉽게 이해할 수 있다
장점 2) 호출될 때 마다 인스턴스를 새로 생성하지 않아도 된다.
장점 3) 반환 타입의 하위 객체를 반환할 수 있는 능력이 있다.
장점 4) 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
장점 5) 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
단점 1) 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
단점 2) 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

2. 생성자에 매개변수가 많다면 빌더를 고려하라.
선택적 매개변수가 많을 경우 적절히 대응하기 어렵다. 그래서 원하는 매개변수를 모두 포함하고 있는 생성자 패턴을 화용을 하는게 일반적이다.
그러나 매개변수에 값을 지정해 줘야하는 단점이 있다. 만약 매개변수가 여러개라면 코드가 읽기도 쓰기도 어려워진다.
그래서 이런 경우 자바빈즈 패턴을 화용한다. 세터를 만들어서 많은 매개변수들을 일일히 지정해주는 것이다.
이렇게 되면 코드는 길어지겠지만 읽기 쉽고 실수하지 않는 코드가 만들어진다.
그러나 자바빈즈 패턴은 객체 하나를 만들려면 여러개의 메서드를 호출해야하고 완성되기전까진 일관성이 무너진 상태가 된다. -> 클래스를 불변으로 만들수 없음. 스레드에 따라 다른 값이 나올수 있는 위험성
그래서 이런 경우 빌더 패턴을 활용하면 생상자패턴과 자바빈즈 패턴의 장점을 흡수하여 안정적 코드를 작성할 수 있다.
이런 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기에 유용하다.
-> 생성자나 정적 팩터리에서 처리해야할 매개변수가 많다면 빌더패턴을 선택하는게 낫다. 

3. private 생성자나 열거타입으로 싱글턴임을 보증하라.
싱글턴: 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다.
1. 생성자를 private로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 한개 마련해둔다.
2. 정적 팩터리 메서드를 public statiic 멤버로 제공한다.
둘다 동일 한 말이지만 인스턴스로 접근하느냐 static메서드로 접근을 하느냐의 차이이다.
3. 원소가 하나인 열거타입을 선언한다.

4. 인스턴스화를 막으려거든 private 생성자를 사용하라
추상클래스로 만드는 것으로는 인스턴스화를 막을 수 없다. -> 하위 클래스를 만들어 인스턴스화할수 있따.
priavate 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.

5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.  
클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 좋은 방법이 아니다.
이런경우 의존객체 주입 패턴을 사용하는게 훨신 좋은 방법이다.
인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식이 있다.-> 의존객체 주입 패턴.

6. 불필요한 객체 생성을 피하라.
생성 비용이 아주 비싼 객체가 있고, 그런 객체를 반복해서 필요하다면 캐싱하여 사용하는게 좋다.
간단한 예로 
String s = new String("test");를 호출할때마다 인스턴스가 만들어진다.
String s = "test"는 새로운 인스턴스를 만들지만 하나의 string 인스턴스만 사용한다.
위의 new String을 잘못사용하면 쓸데 없는 메모리만 먹는 상황이 올 수 있다.
또한 한번만 쓰여지고 버려지는 그런 인스턴스를 사용할 시 반복적 상황에 사용하면 비효율적으로 작동하게 된다.
이런 위험을 피하는 방법중 하나가 박싱된 기본타입보다는 기본타입을 사용하고, 의도치 않는 오토박싱이 숨어들지 않도록 하는 것이다.

7. 다 쓴 객체를 참조를 해제해라 
해제하지 않으면 심할 경우 OutOfMemoryError가 발생할 수 도 있음
가비지 컬렉터의 경우 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체뿐 아니라
그 객체가 참조하는 모든 객체를 회수해가지 못한다. 그래서 객체가 참조해가는 영역을
의도적으로 줄이고 늘리는데 늘리고나서 줄일때 늘려진 부분을 해제하지 않으면 메모리 누수가 발생하게 된다.
리스너, 콜백등을 등록만 하고 해제하지 않는다면 메모리 누수가 발생할 수 있다.
사용후 이제 더이상 리스너,콜백 역할을 하지 않을때에는 해제시켜야한다.
만약 여기서 약한 참조로 해놓는 다면 가비지 컬렉터가 수거를 해간다.

8. finalizer와 cleaner 사용을 피하라.
객체 소멸자로 finalizer와 cleaner가 있다.
둘다 예측할수 없고 상황에 따라 위험할 수 있어 일반적으로 사용하지 않는게 좋다.
c++에서는 소멸자를 통해 객체의 메모리를 가져가는게 일반 적이지만, 자바에서는 그러한 역할은
가비지 컬렉터의 역할이다. 
finalizer와 cleaner는 즉시 수행된다는 보장이 없다. 즉 실행되기까지 얼마나 걸릴지 알수 가 없다. 제때 실행되어야하는 작업은 절대 불가능이다.
finalzer는 가비지 컬렉터보다 심하게 느리고, 그로 인해 효율이 더 떨어진다.
그럼 언제 쓰는가?
1) close 메서드를 호줄하지 않는 것에 대한 안전망 역할이다. 진짜 최악의 경우를 막기 위해 사용하는 것이다.
2) 네이티브 메서드는 가비지 컬렉터에 의해 이루어지지 않는다. 이런 경우에는 finalizer와 cleaner를 사용해야한다.

9. try-finaly보다는 try-with-resources를 사용해라
try-finaly사용시 try에서 open을, finaly에서 close를 할 시에
만약 try에서 exception이 난다면 fianaly에서 해야할 close가 되지 않을 수 있다.
try-with-resoucres를 사용하면 호출되며 바로 회수 되어진다.
만약 꼭 회ㅅ해야하는 자원이라면  try-with-resources를 사용해라.