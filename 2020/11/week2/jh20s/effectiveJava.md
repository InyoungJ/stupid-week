3장
10. equals는 일반 규약을 지켜 재정의하라 

일반적으로 재정의하는게 좋지않다.
재정의 하지 말아야할 상황
1) 각 인스턴스가 본질적으로 고유하다.
2) 인스턴스의 논리적 동치성을 검사할 일이 없다.
3) 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
4) 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.

사용해야하는상황
1) 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의 되지 않았을때 -> 주로 값클래스에서 사용. ex)Integer,String
2) 일반 규약을 따를때.
	일반규약
	1) 반사성 2)대칭성) 3)추이성) 4)일관성 5)null-아님

*구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
*equals를 쓰고싶으면 상속대신 컴포지션을 사용해서 구현해라.

11. equals를 재정의하려거든 hashCode도 재정의하라

equals를 재정의한 클래 모두에서 hashCode도 재정의해야 한다.

두 객체가 같다고 판단했다면 두 객체는 같은 hashcode를 반환해야한다.
만약 해쉬를 재정의 하지않고 hashMap을 사용한다면 
논리적 동치일지라도 두 객체는 서로 다른 해쉬코드를 반환하여 원하지 않는 결과가 나올수있다.

12. tostring을 항상 재정의하라
toString의 일반 규약에 따르면 '간결하면서 사람이 읽기 쉬운 형태의 유익한 정보'를 반환해야한다.
tostring은 내가 사용하지 않더라도 println, printf, 문자열연결 연산자(+)등 어디선가 사용되기에 재정의가 잘되어있으면 유용해진다.
toString을 재정의시 그 객체가 가진 주요 정보를 모두 반환하는게 좋다
이렇게 재정의시에는 포맷을 명시하는게 좋다.

13. clne 재정의를 주의해서 진행하라

clone메서드가 선언된곳은 Object이고 proteced이다
그래서 Clonealbe을 구현하는 것만으로는 외부 객체에서 clone을 호출할 수 없다.
해당 객체가 접근이 허용된 clone메서드를 제공하는 보장이 없기때문이다.

Clonealbe 인터페이스는 Ojbect의 protected 메서드인 clone의 동작 방식을 결정한다

실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며 사용자는 당연히 복제가 제대로 이루어지라 기대한다. -> 이렇게해줘야하는데 이렇게 하면 허술해짐
Clone메서드는 생성자와 같은 효과를 낸다. 즉 Clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야한다.
새로운 인터페이스를 만들 때  절대 Cloneable을 확장해서 안 되며, 새로운 클래스도 이를 구현해선 안된다.

14. comparable을 구현할지 고려하라

Comparable을 구현했다는 것은 인스턴스들에게 자연적인 순서가 있음을 의미한다.
Comparrable이 있으면 정렬을 할때 손 쉽게 가능해 진다.
String에서 정렬이 쉬운것도 알파벳의 Comparable이 있기때문이다.
Comparble은 정의된 것보다 작으면 음의 정수, 같으면 0, 크면 약의 정수를 반환한다. 그외 비교할 수 없는 값이 들어오면 ClassCastException을 던진다.
compareTo을 하고났을때 equlas와 동치성 테스트 결과가 일관되게 나와야한다.
comparable은 타입을 인수로 받는 제너릭 인터페이스이므로 compareTo 메서드의 인수타입은 컴파일타임에 정해진다. -> 인수타입이나 형변환를 고려할 필요가 없다는 말
compareTo 메서드에서 관계 연산자 <와 >를 사용하는 이전방식은 오류를 유발하기때문에 Double.compare와 Float.compare등을 사용하지 않는게 좋다.

4장 클래스와 인터페이스

15. 클래스와 멤버의 접근권한을 최소화하라.
잘 설게된 클래스는 내부데이터와 내부구현정보를 외부 컴포넌트로 잘 숨겨져 있다. -> 정보은닉, 캡슐화가 잘되어 있다.
정보은닉의 장점
	1) 시스템 개발속도를 늘린다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문
	2) 시스템 관리비용을 낮춘다. 각 컴포넌트를 더빨리 파악하여 디버깅이 가능해지기 때문
	3) 정보은닉 자체가 성능을 높여주진 않지만 최적화에 도움이 된다.
	4) 소프트웨어의 재사용성을 높인다.
	5) 큰 시스템을 제작하는 난이도를 낮춰준다.
정보은닉의 핵심
	모든 클래스와 멤버의 접근성을 가능한 좁혀야한다. -> private와 public으로

공개 API를 설계하고 그 외의 모든 멤버는 private로 만드는게 바람직하다.

public클래스의 protected는 공개 API이므로 영원히 지원되야한다. 이런 API는 API문서에 사용자에게 공개해야할 수도 있기에 
protected는 적을수록 좋다.

public 클래스의 인스턴스 필드는 되도록 public이 아니여야한다.
public 가변 필드를 갖는 클래스는 일반적으로 스레드가 안전하지 않다. 
클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다. -> 클라이언트에서 배열의 길이 수정등 배열의 내용을 수정할 수 있기때문에 보안의 허점이 생겨버림
public static으로 사용되는 배열들은 private로 만들어서 사용을 해야한다. 
public을 쓰고싶다면 private를 복사하는 본사본 메서드를 만들어서 방어를 하는 방식으로 사용하면 된다.


16. public 클래스에서는 public 필드가아닌 접근자 메서드를 사용해라
아무 의미없이 pbulic으로 필드를 지정한 값들은 private로 변경을하고 접근이 필요하면 public 접근자(getter)를 추가하는게 바람직하다.
이렇게 하면 패키지 바깥에서 접근할 수 있고 클래스 접근자를 제공함으로써 내부 방식을 언제든 바꿀수 있는 유연함을 제공한다.
단 package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 괜찮다.


17. 변경 가능성을 최소화 하라.
불변 클래스는 간단히 말해 그 인스턴스 내부값을 수정할 수 없는 클래스를 말한다.
불변 클래스는 다음의 5가지 규칙을 따른다
1) 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2) 클래스를 확장할 수 없도록 한다. 대표적으로 final을 선언해 상속을 막아버린다 혹은 pbulic 정적 팩터리를 제공하면 된다.
3) 모든 필드를 final로 선언한다.
4) 모든 필드를 private로 선언한다.
5) 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다. 스레드가 동시에 접근한다 하더라도 절대 훼손되지 않는다.
불변객체는 어떤 스레드도 영향을 줄수 없어 안심하여 공유할 수 있다. 가장 쉬운방법은 public static final로 제공하는 것이다.
-> 이렇게 하면 가비지 컬렉션 비용 또한 줄어들게 된다.
불변 객체는 자유롭게 공유할 수 있음은 물론 불변 객체끼리 내부데이터를 공유할 수 있다.
객체를 만들때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다. 값이 바뀌지 않는 구성요소로 이뤄진 객체라면 그 구조가 복잡해도
불변식이 유지 되기 때문이다.

18. 상속보다는 컴포지션을 사용하라
상속은 코드를 재사용하는 강력한 수단이지만 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다.
메서드 호출과 달리 상속은 캡슐화를 깨뜨리게 된다. -> 상위클래스가 어떻게 구현되느냐에 따라 하위클래스의 동작에 이상이 생길 수 있다.
문제 1) 메소드가 재정의 되어 원치 않는 추가가 될 수 있다.
      2) 허용되지 않는 원소가 추가될 수 있따.
      3) 반환 타입마저 같게 되면 새 메서드를 재정의 한게 되어 빌드에러가 발생할 수 있다.
컴포지션과 전달을 사용하면 하위클래스 이상증상을 피할 수 있다 -> 데코레이터 패턴등을 활용하여 구현한다.

19. 상속을 고려해 설계하고 문서화하라. 그러지 않으면 상속을 금지하라.
상속용 클래스는 재정의할 수 있는 메서들을 내부적으로 어떻게 이용하는지 문서로 남겨야한다. 어떤 호출순서로 호출되는지, 호출결과 이어지는 결과등이 담겨야한다.
메서드 설명에 "Implrementation Requirements'로 시작하는 절이 있는데 해당 부분이 그런 설명이다.
@implSpec 태그를 붙여주면 자바독 도구가 생성해준다.

모든 API를 재구현하게 하는게 아니라면 클래스 내부 동작 과정 중간에 끼어들수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개하는것도 좋은 방법이다.

상속용 클래슬르 시험하는 방법은 직접 하위 클래스를 만들어 보는  것이 '유일'한 방법이다.

이것도 또한 마찬가지로 검증이 필요하다. 상속용으로 설계한 클래스는 배포 전 반드시 하위 클래스를 만들어 검증해야한다.

20. 추상 클래스보다 인터페이스를 우선하라
자바가 제공하는 다중 구현 메커니즘은  인터페이스와 추상클래스 두가지가 있다.
인터페이스를 활용하면 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다.
인터페이스에서 요구하는 메서드를 추가하고 클래스 선언에 implements 구문만 추가하면 된다.
인터페이스로는 계충 구조가 없는 타입 프레임 워크를 만들 수 있다. -> 훨씬 유연함을 가짐.
만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없다.
인터페이스를 사용하면 2^n의 조합폭발이 나는 일을 막을 수 있다. -> 템플릿 메서드 패턴을 화용하면 된다.

21. 인터페이스는 구현하는 쪽을 생각해 설계하라.
기존 자바에는 인터페이스에 메서드를 추가를 못하게했지만 java9 이후부터는 가능해졌다. 그러나 여전히 위험이 존재한다.
생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기는 어렵다.
디폴트 메서드는 기존 구현체에 런타임 오류를 불러일으 킬 수 있다.

22. 인터페이스는 타입을 정의하는 용도로만 사용해라
인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.
다시 말해 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것이다.
상수 인터페이스 안티패턴은 인터페이스의 잘못된 예이다 -> 내부구현을 클래스의 API로 노출하는 행위가 되서이다. 정보은닉에 어긋나게된다.
상수를 사용하고싶다면 MIN_VALUE,MAX_VALUE와 같은 것을. 아니면 열거타입으로 적합하다면 열거타입으로 나타내서 사용하면 된다.

23. 태그 달린 클래스보다 클래스 계층구조를 활용하라.
태그 달린 클래스는 장황하고 오류내기 쉽고 비효율적이다. 태그달린 클래스는 클래스 계층구조루르 어설프게 흉내낸 아류일뿐이다.
태그 달린 클래스 -> 현재 상태를 알려주는 태그필드가 존재하는 클래스.
-> 클래스를 계충구조로 만들면 태그 달린 클래스의 단점이 사라지게 된다. 실수로 빼먹는 case문때문에 발생하는 오류도 사라지게 된다.

24. 멤버 클래스는 되도록 static으로 만들라
중첩 클래스의 종류는 정적 멤버 클래스, 비정적 멤버클래스, 익명클래스, 지역클래스 이렇게 4가지가 있다.
정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있따는 점을 제외하고는 일반 클래스와 똑같다.
정적과 비정적은 구문상의 차이는 static이 있고 없고이지만 비정적 클래스의 인스턴스는 바같 클래의 인스턴스와 암묵적으로 연결된다.
그래서 비정적 메서드에서는 this를 사용해 바깥 인스턴스를 호출하거나 바깥 인스턴스를 참조할 수 있다. -> 비정적 클래스는 인스턴스안에  메모리 공간을 차지하며 생성시간도 오래걸리게 된다.
멤버 클래스에서 바깥 인스턴스에 접근할 일이 ㅇ벗다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.

25. 톱레벨 클래스는 한 파일에 하나만 담으라
톱레벨 클래스를 여러개 선언해도 컴파일러 에러는 나지 않는다.
그러나 빌드때 어느 소스파일을 먼저 건네느냐에 따라 동작이 달라질 수 있다.
그래서 정적 멤버 클래스를 사용하는 방안이 바람직하다.

5장 제너릭
26. 로 타입은 사용하지 말라
클래스와 인터페이스 선언에 타입 매개변수가 쓰이면 제너릭 클래스, 제너릭 인터페이스라고 한다. 
로타입을 쓰면 제너릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.
로타입을 쓰면 런타임에 예외가 날 수 있으니 사용하면 안된다.

27. 비검사 경고를 제거하라
할수 있는한 모든 비검사 경고를 제거하라
비검사 경고는 중요하니 무시하지 말자. 그러나 모든 비검사 경고는 런타임에 익센셥을 일으킬 수 있는 잠재정 가능성이니
최대한 다 제거를 해 안전한 코드임을 증명해야한다.

28. 배열보다는 리스트를 사용하라
배열고 ㅏ제너릭에는 매우 다른 타입 규칙이 적용된다.
배열은 공변이고 실체화되는 반면, 제너릭은 불공변이고 타입 정보가 소거된다.
그결과 런타임에 타입이 안전하지 않지만 컴파일 타임에는 그렇지 않다.

29. 이왕이면 제너릭 타입으로 만들라
클라이언트에서 직접 변환해야하는 타입보다 제너릭 타입이 더 안전하고 쓰게 편하다.
그러나 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 하라.
그렇게 하려면 제너릭 타입으로 만들어야하는 경우가 허다하다.
기존 클라이언트에는 아무영향을 주지않으면서 새로운 사용자를 훨씬 편하게 해주는 길이다.
30. 이왕이면 제너릭 메서드로 만들라
제너릭 타입과 마찬가지로 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환 해야하는 
메서드보다 제너릭 메서드가 더 안전하며 사용하기 쉽다. 타입과 마찬가지로 메서드도 형변환 없이 사용할 수 있는 편이 좋으며
많ㅇ느 경우 그렇게 하려면 제너릭 메서드가 되어야 한다.

31. 한정적 와일드 카드를 사용해 API 유연성을 높이라
조금 복잡하더라도 와일드 카드 타입을 적용하면 API가 훨씬 유연해진다.
그러니 널리 쓰일 라이브러리를 작성한다면 반드시 와일드 카드 타입을 적절히 사용해줘야한다.

32. 제너릭 가변인수를 함께 쓸때는 신중하라
가변인수와 제너릭은 궁합이 좋지 않다. 가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고
배열과 제너릭으 ㅣ타입 규칙이 서로 다르기때문이다. 제너릭 매개변수는 타입 안전하지는 않지만 허용된다.

33. 타입 안전 이종 컨테이너를 고려하라
컬렉션 API로 대표되는 일반적인 제너릭 형태에서 한 컨테이너가 다룰 수 잇는 타입 매개변수의 수가 고정되어 있다.
하지만 컨테이너 자체가 아닌 키를 타입 매개변수로 바꾸면 이런 제약이 없는 타입 안전 이종컨케티어를 만들수 있다.
타입 안전 이종 컨테이너는 Class를 키로 쓰며, 이런 식으로 쓰이는 Class 객체를 토근이라한다.


6장 열거타입과 애너테이션
34. int 상수대신 열거타입을 사용하라
열거타입은 확실히 정수 상수보다 뛰어나다. 더 읽기 쉽고 안전하고 강력하다. 대다수 열거 타입이 명시적
생성자나 메서드 없이 쓰이지만 각 상수를 특정 데이터와 연결짓거나 상수마다 다르게 동작하게 할때는 필요하다.

35. ordinal 메서드 대신 인스턴스 필드를 사용하라
열거타입 상수에 연결된 값은 ordinal 메서드로 얻지말고 인스턴스 필드에 저장하자

36. 비트 필드 대신 Enumset을 사용하라
열거할 수 있는 타입을 한데 모아 집합 형태로 사용한다고 해도 비트 필드를 사용할 이유는 없다. Enumset 클래스가
비트 필드 수준의 명료함과 성능을 제공하고 아이템34에서 설명한 열거타입의 장점까지 선사하기 때문이다.

37. ordinal 인덱싱 대신 EnmMap을 사용하라
배열의 인덱스를 얻기위해 ordinal을 쓰는 것은 일반적으로 좋지 않으니 대신 Enum Map을 사용하라

38. 확장할 수 있는 열거타입이 필요하면 인터페이스를 사용하라
열거타입 자체는 확장할 수 없지만 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 같은효과를 낼 수 있다.
이렇게 하면 클라이언트는 이 인터페이스를 구현해 자신만의 열거타입을 만들 수 있다.
39. 명명 패턴보단 애너테이션을 사용하라

40. Override 애너테이션을 일관되게 사용하라
재정의한 모든 메서드에는 @Override 애너테이션을 의식적으로 달면 실수 했을때 컴파일러가 알려준다.
예외는 한가지뿐이다. 구체 클래스에서 상위 클래스으 ㅣ추상 메서드를 재정의 한 경우엔 애너테이션을 달지 않아도된다.

41. 정의 하려는 것이 타입이라면 마커 인터페이스를 사용하라
적용대상이 ElemnetType인 마커 애너테이션을 작성하고 있따면 
마커 인터페이스로 가능한지에 대해서 다시 생각해보자.
