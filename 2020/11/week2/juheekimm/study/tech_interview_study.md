# 기술 면접 준비

## Spring

### Spring 동작 과정 
![image](https://user-images.githubusercontent.com/26156701/98459082-7b4a8300-21da-11eb-811a-aabcc7d88259.png)
1. 클라이언트(사용자)의 모든 요청은 DispatcherServlet이 받는다.
2. DispatcherServlet은 hanlderMapping을 통해서 요청에 해당하는 Controller를 실행한다.
3. Controller는 적절한 서비스 객체를 호출시킨다.
4. Service는 DB처리를 위해  DAO를 이용하여 데이터를 요청한다.
5. DAO는 mybatis를 이용하는 Mapper를 통해 작업 처리를 한다.
6. 결과(처리한 데이터)가 mapper->DAO->Service->Controller로 전달된다.
7. Contorller는 전달된 결과(처리된 데이터)를 View Resolver를 통해 전달 받을 View가 있는지 검색한다.
8. 전달 받은 View가 있다면 View에게 전달된 결과(처리된 데이터)를 전달한다.
9. View는 전달받은 결과(처리된 데이터)를 다시 DispatcherServlet에게 전달한다.
10. DispatcherServlet은 전달받은 결과(처리된 데이터)를 클라이언트에게 전달한다.

### IoC(Inversion of Control) : 제어의 역전
    모든 객체에 대한 제어권이 바뀐 것을 IoC, 제어의 역전이라 한다.
    
초기에는 객체간의 의존관계를 연결하는 등의 제어권을 개발자가 직접 가지고 있었는데 이 제어권이 스프링 컨테이너로 넘어가서 객체의 생성부터 생명주기의 관리까지 스프링 컨테이너가 하는 것이다.

Dependency Injection(의존성 주입)과 Inversion Of Control(제어의 역전)은 같은 의미로 사용된다. IoC는 DI를 통해 달성된다.

### Dependency Injection(의존성 주입)
    객체간의 의존성을 사용자가 아닌 컨테이너가 빈 설정 정보를 바탕으로 자동으로 해주는 것.

A라는 객체 생성자에서 new B();를 하면 A는 B에 의존하게 된다. 즉, A라는 객체에서 B를 생성하는 것이 아니라 외부에서 생성된 B를 A에 주입함으로써 의존 관계를 없앨 수 있는데, 이를 의존성 주입이라고 한다.	
	
<B>의존성 주입의 장점</b>
- 객체간 의존성 줄여주고
- 코드 재사용이 쉽고
- 테스트가 용이하다

### AOP(Aspect Oriented Programming) (관점 지향 프로그래밍)
    AOP는 애플리케이션 전체에 걸쳐 사용되는 기능을 재사용하도록 지원하는 것이다.

+Spring의 핵심 개념중 하나인 DI 애플리케이션 모듈들 간의 결합도를 낮춰가준다면, AOP는 재사용에 집중.

기존에 OOP에서 바라보던 관점을 다르게 하여 부가기능적인 측면에서 보았을때 공통된 요소를 추출하자는 것. AOP는 핵심 기능과 공통 기능을 분리 시켜놓고 공통 기능을 필요로 하는 핵심 기능들에서 사용하는 방식이다. 즉, AOP는 핵심기능과 공통기능을 분리시킨다.
	

### 서비스추상화
    간단히 이야기하면 개발환경, 혹은 어떠한 비즈니스 로직을 위한 로우레벨의 기술에 구애받지 않게 하기 위해서,
	그리고 책임을 분리 시키기 위한 추상화 개념이다.
	
Ex) 아주 많은 디비의 종류가 있을 때 각자를 관리하기 위해 각각 다른 트랜잭션 코드가 필요하다면?

=> 만약 디비가 바뀌게 된다면 그에 따라 트랜잭션 관리 코드 또한 바뀌어야 할 것이다. 여기서 중요한 개념이 서비스 추상화 개념이다.

트랜잭션을 관리하기 위한 최상위 인터페이스를 선언하고 각 디비에 대한 transactionManager 클래스를 DI해주면? 트랜잭션 관련 코드는 통일되는 동시에 DB가 바뀐다면 DI설정 XML파일만 교체해주면 된다. 디비가 바뀌게 되더라도 트랜잭션 관련코드의 변경은 하나도 없는것이다. 이것이 서비스 추상화의 장점이다.

<b>토비의 Spring 중에서</b> 
> 추상화란 하위 시스템의 공통점을 뽑아내서 분리시키는 것을 말한다. 그렇게 하면 하위 시스템이 어떤 것인지 알지 못해도, 또는 하위 시스템이 바뀌더라도 일관된 방법으로 접근할 수 있다.
	
코드들을 비슷한 것들끼리 모으고(강한 응집력) 서로 다른 코드들이 서로를 구속하지 않는(낮은 결합도) 프로그램 개발을 하는 것을 의미한다.

## Web

### REST(REpresentational State Transfer) : 자원에 의한 상태 전달
    HTTP 통신에서 어떤 자원에 대한 CRUD 요청을 Resource와 Method로 표현하여 URI(Resource)로 요청을 보내는 것
	Get, Post 등의 방식(Method)을 사용하여 요청을 보낸다.
	
요청을 위한 Resource(자원, URI)와 이에 대한 Method(행위, post, get, delete, put 등) 그리고 (자원의 형태,  json, xml, text, rss 등)을 사용하며 이를 REST라 하며, 이러한 규칙을 지켜서 설계된 API를 Rest API 또는 Restful한 API라고 한다.
	
1. 요청을 하는 Client가 플랫폼에 무관하며, 특정 언어나 기술에 종속받지 않는 특징을 의미한다. Rest API는 HTTP를 사용하는 모든 플랫폼에서 요청가능
	
2. Stateless(무상태성)
    
    서버는 각각의 요청을 별개의 것으로 인식하고 처리해야하며, 이전 요청이 다음 요청에 연관되어서는 안된다. 

3. Client-Server Architecture (서버-클라이언트 구조)
	
	Rest API에서 자원을 가지고 있는 쪽이 서버, 자원을 요청하는 쪽이 클라이언트에 해당한다. 서버는 API를 제공하며, 클라이언트는 사용자 인증, Context(세션, 로그인 정보) 등을 직접 관리하는 등 서버와 클라이언트의 역할을 확실히 구분시킴으로써 서로 간의 의존성을 줄인다.
	
	단점) 보안, 정책등에 대한 표준이 없기 때문에 관리가 어렵고 HTTP 프로토콜만 사용가능하다.
	
### CRUD
    작업이름	query	http메서드
    create	insert	post
    read 	select 	get
    update 	update 	put
    delete 	delete 	delete 
	
	HTTP Methods
	HTTP 신호의 타입들을 분류해 놓은 것
	
#### GET
서버에게 resource를 보내달라고 요청한다. 서버(혹은 DB)의 resource는 클라이언트로 전달만 될 뿐 변경되지 않는다. 예를 들어 웹브라우저에 네이버를 입력하면 서버가 해당 route에 표시되어야 하는 페이지를 찾아 보여준다. 웹브라우저 주소창에 주소를 입력하면 이 신호는 항상 get으로 요청된다.

#### POST
서버에게 resource를 보내면서 생성해 달라고 요청한다. 예를들어 회원가입을 하면 DB에 새로운 회원정보가 등록되고, 사진을 업로드 하면 그 사진이 웹사이트에 등록된다.

#### PUT
서버에게 resource를 업데이트 하거나 resource가 없다면 새로운 resource를 생성해 달라고 요청한다. 회원정보 수정 등에 사용됨. PUT은 PATCH와 비교해서 전체 데이터를 교체하는 차이점이 있다. 회원정보 수정시 PUT은 _id를 찾아 age만 업데이트 하더라도 항상 모든 필드값을 가져와서 모든 필드를 항상 새로운 값으로 교체한다.

#### PATCH
서버에게 resource의 업데이트를 요청한다. 회원정보 수정 등에 사용된다. PATCH는 PUT과 비교해서 부분 데이터를 업데이트하는 차이점이 있다. 회원정보 수정시 PATCH는 _id를 찾아 age만 업데이트할때 _id와 age만 받아와서해당 부분을 업데이트 한다.

#### DELETE
서버에게 resource의 삭제를 요청한다.

### jpa(Java Persistence API)
    JPA는 ORM을 사용하기 위한 표준 인터페이스를 모아둔 것으로 애플리케이션과 JDBC 사이에서 동작한다.

개발자가 JPA를 사용하면, JPA 내부에서 JDBC API를 사용하여 SQL을 호출하여 DB와 통신한다. 즉, 개발자가 직접 JDBC API를 쓰는 것이 아니다.

### ORM(Object-relational mapping)
    ORM이란 객체와 DB의 테이블이 매핑. 객체가 테이블이 되도록 매핑 시켜주는 것을 말한다.

JDBC API 와 DB 사이에서 동작, 내부에서 JDBC로 SQL을 호출해서 DB와 통신한다. 
	
ORM을 이용하면 SQL Query가 아닌 직관적인 코드(메서드)로서 데이터를 조작할 수 있다. MySQL에서는 SELECT * FROM user; 라는 query를 실행해야 하지만, ORM을 사용하면 user.findAll() 라는 메서드 호출로 데이터 조회가 가능하다.
	
query를 직접 작성하지 않고 메서드 호출만으로 query가 수행되다 보니, ORM을 사용하면 생산성이 매우 높아진다. 그러나 query가 복잡해지면 ORM으로 표현하는데 한계가 있고, 성능이 raw query에 비해 느리다는 단점이 있다.
	
#### JDBC API를 사용했을 때의 문제
- 유사한 CURD SQL 반복 작업
- 객체를 단순히 데이터 전달 목적으로 사용할 뿐, 객체 지향적이지 못함 ( 페러다임 불일치 )
- 그래서 orm이 뜨면서 jpa라는 표준이 정해짐

#### ORM 장점
- 객체 지향적 코드로 인해 더 직관적이고 비즈니스 로직에 집중할 수 있도록 도와준다. CRUD을 위한 긴 SQL 문장을 작성할 필요가 없다. (여전히 쿼리작성은 필요하지만)
- 재사용 및 유지보수의 편리성이 증가한다. ORM은 독립적으로 작성이 되어 있고 해당 객체들은 재사용이 가능하다.
- DBMS에 대한 종속성이 줄어든다.
- 기존에는 필드 변경시 모든 SQL을 수정해야 한다. insert, select, update 모두. 하지만, JPA는 필드만 추가하면 된다. SQL은 JPA가 처리한다.

#### ORM 단점
- 사용하기에는 편하지만 설계에는 매우 신중해야 한다. 잘못 구현된 경우 속도 저하 및 심한 경우 일관성이 무너지는 문제점이 생길 수 있다.
- 직접 SQL을 호출하는 것보다 성능이 떨어질 수 있습니다.
- 러닝커브가 높다

## Java

### Java 8 ver에 추가된 기능

#### interface default method
기존에 있던 인터페이스에 새로운 추상메서드가 추가된다면 해당 인터페이스를 구현하고 있는 모든 클래스에서 그 메서드를 강제 구현해야하는 불상사가 생기는데 그래서 추가된 기능이 default이다. default를 메서드 앞에 붙여주면 그 메서드는 구현하지않아도 문제가 되지 않는다.
	
#### 람다식
메서드를 하나의 '식(expression)'으로 표현한 것이다. 메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, '익명 함수(anonymous function)'이라고도 한다.
	
위의 메서드는 클래스에 포함되어야 하므로 클래스를 새로 만들어야 하고, 객체도 생성해야만 비로소 필요한 메서드를 호출 할 수 있다. 그러나 람다식은 이 모든 과정없이 오직 람다식 자체만으로도 이 메서드의 역할을 대신할 수 있다. 게다가 람다식은 메서드의 매개변수로 전달되어지는 것이 가능하고, 메서드의 결과로 반환 될 수도 있다.
	
#### 스트림
스트림은 '데이터의 흐름’입니다. 배열 또는 컬렉션 인스턴스에 함수 여러 개를 조합해서 원하는 결과를 필터링하고 가공된 결과를 얻을 수 있다.

또한 람다를 이용해서 코드의 양을 줄이고 간결하게 표현할 수 있다. 즉, 배열과 컬렉션을 함수형으로 처리할 수 있다. 여러 빌딩 블록 연산을 연결해서 복잡한 데이터 처리 파이프라인을 만들 수 있다.
	
#### 옵셔널
Optional은 null 또는 실제 값을 value로 갖는 wrapper로 감싸서 NPE(NullPointerException)로부터 자유로워지기 위해 나온 Wrapper 클래스이다. 만약 어떤 데이터가 null이 올 수 있는 경우에는 해당 값을 Optional로 감싸서 생성할 수 있다.

그리고 orElse 또는 orElseGet 메소드를 이용해서 값이 없는 경우라도 안전하게 값을 가져올 수 있다. 또한 Optional은 값을 Wrapping하고 다시 풀고, null일 경우에는 대체하는 함수를 호출하는 등의 오버헤드가 있으므로 성능이 저하될 수 있다.

