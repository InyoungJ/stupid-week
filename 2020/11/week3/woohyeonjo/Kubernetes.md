# 도커와 쿠버네티스 시작하기

> 강의에 대해서 설명 ~ 7강

### 왜 쿠버네티스인가?

**모놀리식 아키텍처에서 마이크로 서비스로 변화한다.**

- 모놀리식 서비스 아키텍처
  - 서비스가 하나의 애플리케이션으로 돌아가는 구조
  - 단점
    - 스케일링시 기존의 애플리케이션을 그대로 복제하여 로드밸런싱(불필요한 서비스까지 모두 복제)
    - 종속적인 라이브러리의 충돌
    - 조금만 수정해도 전체 빌드 및 배포 필요
- 마이크로 서비스
  - 애플리케이션의 각각의 기능을 분리하여 개발 및 관리
  - 모놀리식 서비스 아키텍처의 단점을 보완한 것이 장점
    - 서비스 단위 고효율 저비용 Scale-Out 구조
    - 라이브러리 종속성 고민 해결



**이미지, 컨테이너, 도커와 쿠버네티스**

- 컨테이너(용기)

  - 환경을 격리시키는 역할을 한다.

    - 리눅스 커널의 기능을 이용해서 환경을 나눈다.

      > 리눅스 네임 스페이스
      >
      > 각 프로세스가 파일 시스템 마운트, 네트워크, 유저(uid), 호스트 네임(uts) 등에 대해 시스템에 독립 뷰를 제공

      > 리눅스 컨트롤 그룹
      >
      > 프로세스로 소비할 수 있는 리소스 양(CPU, 메모리, I/O, 네트워크 대역대, device 노드 등)을 제한

    - 가상환경 구축에 리소스가 굉장히 적게 들어간다. 따라서 기존 가상머신에 비해 효율적이다.

- 도커(항만 노동자)

  - 다수의 컨테이너를 편리하게 사용할 수 있도록 하는 것
  - 컨테이너 기술을 지원하는 다양한 프로젝트 중에 하나
  - 다양한 운영체제에서 사용가능(리눅스, 윈도우, MacOS)
    - 하지만, 리눅스 외에는 하이퍼바이저가 필요함
  - 컨테이너와 이미지
    - 컨테이너는 이미지를 격리하여 독립된 공간에서 실행한 가상 환경
    - 이미지는 필요한 프로그램과 라이브러리, 소스를 설치한 뒤 만든 하나의 파일
  - 도커 아키텍처
    - Docker engine: 이미지, 네트워크, 디스크 등의 관리 역할
    - Containerd: OCI 구현체(주로 runC)를 이용해 container를 관리해주는 daemon
    - 두 프로그램이 각각 돌아가기 때문에 Docker Engine을 재시작해도 각 이미지에 영향이 없음
  - 도커의 한계
    - 서비스가 커지면 커질 수록 관리해야 하는 컨테이너의 양이 급격히 증가
    - 도커를 사용하여 관리를 한다 하더라도 쉽지않은 형태
    - **오케스트레이션을 위해서 쿠버네티스를 사용**

- 쿠버네티스(항해자)

  - 다수의 도커를 쉽게 관리할 수 있도록 하는 것

  - 2014년 구글이 오픈 소스 공개 (Go로 만듬)

    

**마이크로서비스 성공 사례**

- 넷플릭스
- 아마존
  - 엄청난 수의 배포
- 우아한 형제들
  - 모놀리식 아키텍처에서 마이크로서비스 전환기를 거쳤던 과도기의 구조
- 라인
  - Nucleo

