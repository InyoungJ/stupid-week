From bf20cf807644b3be76051534b311f93461ee961b Mon Sep 17 00:00:00 2001
From: Sunwook Eom <sunwook5492@gmail.com>
Date: Sat, 14 Nov 2020 12:35:56 +0900
Subject: [PATCH] Chap 04 - Zero_overhead_abstraction is done !

The assembly code in cpu.S is replaced by Rust code from the [cortex-a] crate,
which provides zero-overhead abstractions and wraps the `unsafe` parts.

[0] Hello This is eom from pure Rust world !
[1] Stopping here !

Signed-off-by: Sunwook Eom <sunwook5492@gmail.com>

diff --git a/nook_os/Cargo.lock b/nook_os/Cargo.lock
index 18f279f..c045870 100644
--- a/nook_os/Cargo.lock
+++ b/nook_os/Cargo.lock
@@ -1,5 +1,32 @@
 # This file is automatically @generated by Cargo.
 # It is not intended for manual editing.
 [[package]]
+name = "cortex-a"
+version = "3.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ad53da88d3deae442c1d6d3d7f3c1ba101520736e01ddb12acb17783b745aff5"
+dependencies = [
+ "register",
+]
+
+[[package]]
 name = "kernel"
 version = "0.1.0"
+dependencies = [
+ "cortex-a",
+]
+
+[[package]]
+name = "register"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "deaba5b0e477d21f61a57504bb5cef4a1e86de30300b457d38971c1cfc98b815"
+dependencies = [
+ "tock-registers",
+]
+
+[[package]]
+name = "tock-registers"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "70323afdb8082186c0986da0e10f6e4ed103d681c921c00597e98d9806dac20f"
diff --git a/nook_os/Cargo.toml b/nook_os/Cargo.toml
index 5698be1..561697f 100644
--- a/nook_os/Cargo.toml
+++ b/nook_os/Cargo.toml
@@ -7,8 +7,10 @@ edition = "2018"
 # The features section is used to select the target board.
 [features]
 default = []
-bsp_rpi3 = []
-bsp_rpi4 = []
-
+bsp_rpi3 = ["cortex-a"]
+bsp_rpi4 = ["cortex-a"]
 
 [dependencies]
+
+# Optional dependencies
+cortex-a = { version = "3.0.x", optional = true }
diff --git a/nook_os/src/_arch/aarch64/cpu.S b/nook_os/src/_arch/aarch64/cpu.S
deleted file mode 100644
index 8123daa..0000000
--- a/nook_os/src/_arch/aarch64/cpu.S
+++ /dev/null
@@ -1,18 +0,0 @@
-.section ".text._start"
-
-.global _start
-
-_start:
-    mrs     x1, mpidr_el1   // Read Multiprocessor Affinity Register
-    and     x1, x1, #3      // Clear all bits except [1:0], which hold core id
-    cbz     x1, 2f          // Jump to label 2 if we are core 0
-1:  wfe                     // Wait for event
-    b       1b              // In case an event happened, jump back to 1
-2: 
-    ldr     x1, =_start     // Load address of function "_start()"
-    mov     sp, x1          // Set start of stack to before our code, aka first
-                            // address before "_start()"
-                            // but, why should we do that?
-    bl      runtime_init    // Jump to the "runtime_init()" kernel function
-    b       1b              // We should never reach here. But just in case,
-                            // park this core aswell
diff --git a/nook_os/src/_arch/aarch64/cpu.rs b/nook_os/src/_arch/aarch64/cpu.rs
index c379be8..b2cc071 100644
--- a/nook_os/src/_arch/aarch64/cpu.rs
+++ b/nook_os/src/_arch/aarch64/cpu.rs
@@ -1,20 +1,34 @@
-// Assembly counterpart to this file.
-global_asm!(include_str!("cpu.S"));
+//! Architectural processor code.
+
+use cortex_a::{asm, regs::*};
+use crate::{bsp, cpu};
 
 //--------------------------------------------------------------------------------------------------
 // Public Code
 //--------------------------------------------------------------------------------------------------
 
+/// The entry of the `kernel` binary.
+///
+/// The function must be named `_start`, because the linker is looking for this exact name.
+///
+/// # Safety
+///
+/// - Linker script must ensure to place this function at `0x8_0000`.
+#[naked]
+#[no_mangle]
+pub unsafe fn _start() -> ! {
+    if bsp::cpu::BOOT_CORE_ID == cpu::smp::core_id() {
+        SP.set(bsp::memory::BOOT_CORE_STACK_START as u64);
+        crate::runtime_init::runtime_init();
+    } else {
+        wait_forever();
+    }
+}
+
 /// Pause execution on the core.
 #[inline(always)]
 pub fn wait_forever() -> ! {
-    unsafe {
-        loop {
-            #[rustfmt::skip]
-            asm!(
-                "wfe",
-                options(nomem, nostack, preserves_flags)
-            );
-        }
+    loop {
+        asm::wfe();
     }
 }
diff --git a/nook_os/src/_arch/aarch64/cpu/smp.rs b/nook_os/src/_arch/aarch64/cpu/smp.rs
new file mode 100644
index 0000000..c562934
--- /dev/null
+++ b/nook_os/src/_arch/aarch64/cpu/smp.rs
@@ -0,0 +1,13 @@
+//! Architectural symmetric multiprocessing.
+
+use cortex_a::regs::*;
+
+/// Return the executing core's id.
+#[inline(always)]
+pub fn core_id<T>() -> T
+where
+    T: From<u8>,
+{
+    const CORE_MASK: u64 = 0b11;
+    T::from((MPIDR_EL1.get() & CORE_MASK) as u8)
+}
diff --git a/nook_os/src/bsp/raspberrypi.rs b/nook_os/src/bsp/raspberrypi.rs
index 5b9849f..1b21f7b 100644
--- a/nook_os/src/bsp/raspberrypi.rs
+++ b/nook_os/src/bsp/raspberrypi.rs
@@ -1 +1,3 @@
 pub mod console;
+pub mod cpu;
+pub mod memory;
diff --git a/nook_os/src/bsp/raspberrypi/cpu.rs b/nook_os/src/bsp/raspberrypi/cpu.rs
new file mode 100644
index 0000000..08f3f86
--- /dev/null
+++ b/nook_os/src/bsp/raspberrypi/cpu.rs
@@ -0,0 +1,5 @@
+//! BSP Processor code.
+
+/// Used by `arch` to find the early boot core.
+pub const BOOT_CORE_ID: usize = 0;
+
diff --git a/nook_os/src/bsp/raspberrypi/memory.rs b/nook_os/src/bsp/raspberrypi/memory.rs
new file mode 100644
index 0000000..c4fd3ba
--- /dev/null
+++ b/nook_os/src/bsp/raspberrypi/memory.rs
@@ -0,0 +1,5 @@
+//! BSP Memory Management.
+
+
+/// The early boot core's stack address.
+pub const BOOT_CORE_STACK_START: usize = 0x8_0000;
diff --git a/nook_os/src/cpu.rs b/nook_os/src/cpu.rs
index f865e93..fd6cc7d 100644
--- a/nook_os/src/cpu.rs
+++ b/nook_os/src/cpu.rs
@@ -1,4 +1,8 @@
+//! Processor code.
+
 #[cfg(target_arch = "aarch64")]
 #[path = "_arch/aarch64/cpu.rs"]
 mod arch_cpu;
 pub use arch_cpu::*;
+
+pub mod smp;
diff --git a/nook_os/src/cpu/smp.rs b/nook_os/src/cpu/smp.rs
new file mode 100644
index 0000000..15fb1ff
--- /dev/null
+++ b/nook_os/src/cpu/smp.rs
@@ -0,0 +1,6 @@
+//! Symmetric multiprocessing.
+
+#[cfg(target_arch = "aarch64")]
+#[path = "../_arch/aarch64/cpu/smp.rs"]
+mod arch_cpu_smp;
+pub use arch_cpu_smp::*;
diff --git a/nook_os/src/main.rs b/nook_os/src/main.rs
index e1176dc..e403cc2 100644
--- a/nook_os/src/main.rs
+++ b/nook_os/src/main.rs
@@ -1,7 +1,6 @@
 //! The `kernel` binary.
 
-#![feature(asm)]
-#![feature(global_asm)]
+#![feature(naked_functions)]
 #![feature(panic_info_message)]
 #![feature(format_args_nl)]
 #![no_main]
@@ -21,6 +20,8 @@ mod print;
 ///
 /// - Only a single core must be active and running this function.
 unsafe fn kernel_init() -> ! {
-    println!("[0] Hello This is eom");
-    panic!("Kernel init is done.. So kill myself!!!");
+    println!("[0] Hello This is eom from pure Rust world !");
+    println!("[1] Stopping here !");
+
+    cpu::wait_forever();
 }
diff --git a/nook_os/src/runtime_init.rs b/nook_os/src/runtime_init.rs
index bb08258..1ee1995 100644
--- a/nook_os/src/runtime_init.rs
+++ b/nook_os/src/runtime_init.rs
@@ -18,8 +18,7 @@ unsafe fn zero_bss(){
     memory::zero_volatile(get_bss_range());
 }
 
-#[no_mangle]
-pub unsafe extern "C" fn runtime_init() -> ! {
+pub unsafe fn runtime_init() -> ! {
     zero_bss();
 
     crate::kernel_init()
-- 
2.7.4

