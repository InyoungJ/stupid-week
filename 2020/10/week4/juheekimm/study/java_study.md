# 자바 면접 대비

## 1. 자바를 쓰는 이유
- 객체 지향 개념의 특징인 캡슐화, 상속, 다형성, 추상이 잘 적용된 언어
- Garbage Collector를 통한 메모리관리기능
- 멀티쓰레드(Multi-thread)를 지원한다.
	
### 1) 독립적
윈도우 운영체제에서 C로 개발한 프로그램을 컴파일하면 ‘실행 파일'이 만들어집니다

그런데 이 실행 파일은 윈도우 운영체제에 맞게 만들어졌기 때문에 만약 리눅스에서 실행하려면, 다시 컴파일해서 실행 파일을 새로 만들어야 합니다
	
반면 자바에서 .java로 끝나는 프로그램을 컴파일하면 바이트 코드인 .class 파일이 생성됩니다.
	
자바는 운영체제에서 직접 실행하는게 아니라  JVM에서 .class 파일을 실행해서 각 운영체제에 맞는 실행파일을 만들어 줍니다

즉 .class 파일만 있으면 운영체제와 상관없어 어떤 환경에서나 실행할 수 있게 돼서 자바는 다른 언어와 다르게 플랫폼에 독립적이고 대신 JVM이 플랫폼에 의존, 종속적이어서 리눅스의 JVM과 윈도우의 JVM은 다릅니다

### 2) 안정적
1. C++과의 차이

    C++도 객체지향 언어인데 자바는 포인터를 사용하지 않기 때문에 사용자가 메모리를 직접 제어할 수 없습니다.
    프로그램에서 사용자가 메모리를 직접 제어하면 오류가 발생할 수 있는데,
    자바는 이러한 위험성을 아예 막아버림으로써 안전을 추구했다고 생각합니다.

2. 다중상속 지원 X
    자바는 시스템에 문제생길만한 가능성을 아예 남겨두지 않으려고 하는데, 다중상속은 문제 발생 가능성이 있음.
    근데 다중상속도 좋은 점이 많은데.. 아쉬우니까 interface를 이용해서 이와 비슷한 느낌으로 지원
	
## 2. jvm이란
jvm Java Virtual Machine 자바 가상머신

	메모리관리, gc를 수행하는 스택 기반의 가상머신
	왜 알아야 하는가? 한정된 메모리를 효율적으로 사용하여 최고의 성능을 내기 위해서
	따라서 메모리를 효율적으로 사용하기 위해서는 메모리의 구성과 각 특징에 대해서 이해할 필요가 있다.

JRE Java Runtime Environment 자바 실행 환경

	JRE는 자바 가상머신이 자바 프로그램을 동작시킬 때 필요한 라이브러리 파일들과 기타 파일들을 가지고 있다.
	JRE는 JVM의 실행환경을 구현했다고 할 수 있다.
	(그래서 운영체제에 종속적)
	
JDK Java Development Kit 자바 개발 도구

	JRE + 개발을 위해 필요한 도구(javac, java등)들을 포함한다.

## 3. 자바 메모리
### Stack
힙 영역에 생성된 Object타입 데이터의 참조값이 할당된다

원시타입(primitive)의 데이터가 값과 함께 할당된다 - 참조값 아니고 실제값 저장
   
    원시타입 데이터는 인자로 넘겨도, 그 값이 파라미터로 복사돼서 stack에 할당된다

지역변수들은 scope 에 따른 접근성을 (visibility) 가진다.
    
    해당 지역변수는 다른 함수(scope를 벗어나면)에서 접근 불가능. 그리고 함수가 종료되면 스택에서 pop되어 사라진다
    main() 함수도 종료되는 순간 stack 에 있는 모든 데이터들은 pop 되면서 프로그램이 종료된다.

Stack 메모리는 Thread 하나당 하나씩 할당된다
  
    즉, 스레드 하나가 새롭게 생성되는 순간 해당 스레드를 위한 stack 도 함께 생성되며,
    각 스레드에서 다른 스레드의 stack 영역에는 접근할 수 없다.

### Heap
- 애플리케이션의 모든 메모리 중 stack 에 있는 데이터를 제외한 부분이라고 보면 된다.

- 모든 Object 타입(Integer, String, ArrayList, ...)및 Object를 상속받은 것들은 heap 영역에 생성된다.
    (Object 타입은 최상위 부모클래스다, 다형성 에 의해 Object 타입으로 레퍼런스 가능)

- 몇개의 스레드가 존재하든 상관없이 단 하나의 heap 영역만 존재(쓰레드들은 힙 영역을 공유)한다.

- new 키워드는 생성하려는 오브젝트를 저장할 수 있는 충분한 공간이 heap 에 있는지 먼저 찾은 다음, 빈 List 를 참조하는 listArgument 라는 로컬변수를 스택에 할당한다.
    
    list.add("11번가")를 하면, 그에 할당된 문자열인 11번가를 가리키는 변수는 스택이 아닌 힙에 할당된다. List 내부의 인덱스에 의해 하나씩 add() 된 데이터에 대한 레퍼런스 값을 갖게 된다. 

- Object 타입의 데이터, 즉 heap 영역에 있는 데이터는 파라미터로 참조값을 넘겨서 값을 변경하더라도 함수호출이 종료된 시점에 변경내역이 반영되는 것을 볼 수 있다.

- 자바에서 Wrapper class 에 해당하는 Integer, Character, Boolean클래스는 모두 Immutable(불변) 이다.
    
    그래서 heap 에 있는 같은 오브젝트를 레퍼런스 하고 있는 경우라도,
    새로운 연산이 적용되는 순간 기존 값을 바꾸는게 아니라, 새로운 오브젝트가 heap 에 새롭게 할당된다.
   
    a = "hello"
    
    a += "world"하면 hello에 world를 붙이는게 아니라, "hello world"라는 문자열을 새로 생성한다.
    
    근데 생성해놓고 함수가 끝나면 그 참조하던 변수는 stack에서 pop되기 때문에 참조가 끊긴다
    그럼 이렇게 생성된 hello world는 가비지로 분류된다.
    
    Integer 클래스를 까보면 내부에서 사용하는 실제 값인 value 라는 변수가 있는데,
    이 변수는 private final int value; 로 선언 되어있다.
    
    즉, 생성자에 의해 생성되는 순간에만 초기화되고 변경불가능한 값이 된다.
    (불변객체는 재할당은 가능하지만, 한번 할당하면 내부 데이터를 변경할 수 없는 객체)
    이것 때문에 Wrapper class 들도 String 처럼 Immutable 한 오브젝트가 되는 것이다.
